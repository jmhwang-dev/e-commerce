# 🛠️ Olist 피처 구현 가이드

## 📋 개요
Olist 데이터셋에서 구현하기 어려운 피처들에 대한 실용적인 구현 방안을 제시합니다.

---

## 🚫 외부 데이터 필요 피처 구현 방안

### 1. `weather_on_shipping_day` - 출고일 기준 날씨 정보

| 구현 방법 | 난이도 | 비용 | 설명 |
|-----------|--------|------|------|
| **하드코딩** | ⭐ | 무료 | 계절별 평균 기온/강수량 매핑 테이블 생성 |
| **OpenWeatherMap API** | ⭐⭐ | 유료 | 과거 날씨 데이터 API 호출로 정확한 날씨 정보 수집 |
| **INMET 크롤링** | ⭐⭐⭐ | 무료 | 브라질 기상청 웹사이트에서 과거 기상 데이터 스크래핑 |

### 2. `is_order_on_holiday` - 브라질 공휴일 여부

| 구현 방법 | 난이도 | 비용 | 설명 |
|-----------|--------|------|------|
| **holidays 라이브러리** | ⭐ | 무료 | Python holidays 패키지로 브라질 공휴일 자동 판별 |
| **수동 딕셔너리** | ⭐ | 무료 | 주요 연방 공휴일만 하드코딩하여 매핑 |
| **정부 달력 API** | ⭐⭐ | 무료 | 브라질 정부 공식 달력 데이터 연동 |

### 3. `road_strike_indicator` - 도로 파업 정보

| 구현 방법 | 난이도 | 비용 | 설명 |
|-----------|--------|------|------|
| **알려진 파업일 매핑** | ⭐⭐ | 무료 | 2018년 트럭 파업 등 주요 파업 기간 하드코딩 |
| **NewsAPI** | ⭐⭐⭐ | 유료 | 실시간 뉴스 데이터에서 파업 관련 키워드 탐지 |
| **정부 공지 크롤링** | ⭐⭐⭐ | 무료 | 교통부/노동부 공지사항에서 파업 정보 수집 |

### 4. `federal_holiday_flag` - 연방 공휴일 플래그

| 구현 방법 | 난이도 | 비용 | 설명 |
|-----------|--------|------|------|
| **is_order_on_holiday와 통합** | ⭐ | 무료 | 기존 공휴일 피처와 동일한 로직 사용 |
| **영업일 계산** | ⭐⭐ | 무료 | pandas BDay() 함수로 영업일 기준 공휴일 판별 |

### 5. `is_remote_area` - 외곽 지역 여부

| 구현 방법 | 난이도 | 비용 | 설명 |
|-----------|--------|------|------|
| **주요 도시 기준** | ⭐⭐ | 무료 | 상파울루, 리우 등 주요 도시 외 지역을 외곽으로 분류 |
| **인구밀도 기준** | ⭐⭐ | 무료 | IBGE 인구 데이터로 인구밀도 기준 도시/시골 분류 |
| **GPS 클러스터링** | ⭐⭐⭐ | 무료 | geolocation 좌표 기반 클러스터링으로 지역 분류 |
| **경제지표 활용** | ⭐⭐⭐ | 유료 | GDP, 소득수준 등 복합 지표로 도시 등급 분류 |

---

## 📊 복잡한 계산 피처 구현 방안

### 1. `customer_avg_order_interval_days` - 고객 평균 주문 간격

| 구현 방법 | 난이도 | 성능 | 설명 |
|-----------|--------|------|------|
| **groupby + diff** | ⭐⭐ | 보통 | 고객별 그룹화 후 주문일 차분 계산 |
| **SQL 윈도우 함수** | ⭐⭐ | 좋음 | LAG() 함수로 이전 주문일과 차이 계산 |
| **vectorized 연산** | ⭐⭐⭐ | 최고 | numpy 기반 최적화된 벡터 연산 |

**주의사항**: 첫 주문 고객은 NaN 처리 또는 0으로 설정 필요

### 2. `days_since_last_order` - 마지막 주문 이후 일수

| 구현 방법 | 난이도 | 성능 | 설명 |
|-----------|--------|------|------|
| **시점별 이전 주문 계산** | ⭐⭐ | 보통 | 각 주문별로 해당 고객의 바로 이전 주문일 계산 |
| **merge_asof 활용** | ⭐⭐⭐ | 좋음 | 시계열 조인으로 효율적인 이전 주문 매칭 |
| **고성능 벡터화** | ⭐⭐⭐ | 최고 | numpy 기반 대용량 데이터 최적화 |

**주의사항**: 데이터 리키지 방지를 위해 시점 기준 과거 데이터만 사용

### 3. `seller_lead_time_stability` - 셀러 배송시간 안정성

| 구현 방법 | 난이도 | 정확도 | 설명 |
|-----------|--------|--------|------|
| **기본 표준편차** | ⭐⭐ | 보통 | 셀러별 배송일수의 표준편차 또는 변동계수 계산 |
| **롤링 윈도우** | ⭐⭐⭐ | 좋음 | 최근 N개 주문 기준 이동 표준편차로 트렌드 반영 |
| **이상치 제거** | ⭐⭐⭐ | 최고 | IQR 방식으로 이상치 제거 후 안정성 지표 계산 |

**활용 팁**: 변동계수(CV = std/mean) 사용 시 평균 대비 상대적 안정성 측정 가능

### 4. `customer_cluster_id` - 고객 클러스터링

| 구현 방법 | 난이도 | 비즈니스 가치 | 설명 |
|-----------|--------|---------------|------|
| **RFM 분석** | ⭐⭐ | 높음 | Recency, Frequency, Monetary 기반 K-means 클러스터링 |
| **행동 패턴 분석** | ⭐⭐⭐ | 매우 높음 | 주문 시간, 요일, 카테고리 선호 등 다차원 분석 |
| **계층적 클러스터링** | ⭐⭐⭐ | 높음 | 덴드로그램 기반 최적 클러스터 수 결정 |

**권장사항**: 먼저 RFM으로 시작하여 비즈니스 인사이트 확인 후 고도화

### 5. `seller_behavior_embedding` - 셀러 행동 임베딩

| 구현 방법 | 난이도 | 표현력 | 설명 |
|-----------|--------|--------|------|
| **카테고리 기반 PCA** | ⭐⭐ | 보통 | 셀러별 판매 카테고리 원핫인코딩 후 차원축소 |
| **Node2Vec** | ⭐⭐⭐ | 높음 | 셀러-고객 상호작용 그래프 기반 임베딩 |
| **AutoEncoder** | ⭐⭐⭐⭐ | 매우 높음 | 딥러닝 기반 셀러 특성 압축 표현 |

**단계적 접근**: PCA → Node2Vec → AutoEncoder 순으로 복잡도 증가

---

## 🎯 구현 우선순위 가이드

### Phase 1: 기본 구현 (1-2주)
- **목표**: 빠른 MVP 구축으로 베이스라인 성능 확보
- **방법**: 하드코딩, 무료 라이브러리 활용
- **우선순위**: 공휴일 정보 > 고객 주문 간격 > 셀러 안정성
- **성공 기준**: 기능 동작 여부, 성능보다는 완성도 우선

### Phase 2: 품질 향상 (2-4주)
- **목표**: 데이터 품질 개선으로 예측 성능 향상
- **방법**: 외부 API 연동, 계산 최적화
- **우선순위**: 날씨 정보 > 지역 분류 > 고급 클러스터링
- **성공 기준**: 모델 성능 5-10% 향상

### Phase 3: 고도화 (4-8주)
- **목표**: ML 기반 고급 피처로 차별화된 성능 달성
- **방법**: 딥러닝, 그래프 알고리즘, 실시간 처리
- **우선순위**: 임베딩 > 파업 탐지 > 실시간 업데이트
- **성공 기준**: 프로덕션 안정성, 확장성 확보

### 💰 비용 대비 효과 분석

| 피처 유형 | 구현 비용 | 예상 성능 향상 | 개발 시간 | ROI 점수 |
|-----------|-----------|---------------|-----------|----------|
| 공휴일 정보 | 낮음 | 중간 | 1일 | ⭐⭐⭐⭐⭐ |
| 고객 주문 간격 | 낮음 | 높음 | 2-3일 | ⭐⭐⭐⭐⭐ |
| 셀러 안정성 | 중간 | 중간 | 3-5일 | ⭐⭐⭐⭐ |
| RFM 클러스터링 | 중간 | 높음 | 1주 | ⭐⭐⭐⭐ |
| 날씨 정보 | 중간 | 낮음 | 1주 | ⭐⭐⭐ |
| 지역 분류 | 높음 | 중간 | 2주 | ⭐⭐⭐ |
| 파업 탐지 | 높음 | 낮음 | 2-3주 | ⭐⭐ |
| 딥러닝 임베딩 | 매우 높음 | 중간 | 4-6주 | ⭐⭐ |

## 🚨 주의사항 및 리스크

### 데이터 리키지 방지
- **시점 기준 집계**: 미래 정보가 과거 예측에 사용되지 않도록 주의
- **타겟 변수 오염**: 지연 여부와 직접 연관된 정보 사용 금지
- **검증 전략**: 시계열 분할로 리키지 검증

### 성능 최적화
- **메모리 관리**: 대용량 groupby 연산 시 청크 단위 처리
- **계산 복잡도**: O(n²) 연산 지양, 벡터화 연산 활용
- **캐싱 전략**: 중간 결과 저장으로 재계산 방지

### 비즈니스 해석 가능성
- **피처 중요도**: 모델 성능과 함께 해석 가능성 고려
- **도메인 지식**: 브라질 문화, 물류 특성 반영
- **스테이크홀더 소통**: 기술적 복잡성을 비즈니스 가치로 변환

## 📝 결론

구현 가능성, 비즈니스 임팩트, 개발 리소스를 종합 고려하여 **Phase 1 → Phase 2 → Phase 3** 순서로 단계적 접근을 권장합니다. 

특히 **공휴일 정보**와 **고객 주문 간격** 피처는 낮은 비용으로 높은 효과를 기대할 수 있어 최우선 구현 대상입니다.