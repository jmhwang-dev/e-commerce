# Olist 피처 구현 가이드

## 개요
Olist 데이터셋에서 구현 난이도가 높은 피처들에 대한 계산 방식과 실용적인 구현 전략을 정리합니다. 외부 데이터 의존성과 계산 복잡도에 따라 단계별로 접근합니다.

## 복잡한 계산이 필요한 피처

| Feature Name                    | Data Source                                                   | 계산 로직                                                    | Description                                                           |
|---------------------------------|----------------------------------------------------------------|--------------------------------------------------------------|------------------------------------------------------------------------|
| `customer_avg_order_interval_days` | `orders` (`order_purchase_timestamp`)                           | 고객별 주문일 정렬 → 차이 계산 → 평균값                       | 고객 평균 주문 간격. 재구매 주기 파악에 유용.                         |
| `days_since_last_order`        | `orders` (`order_purchase_timestamp`)                           | 고객별 마지막 주문일 추출 → 기준일과 차이 계산                | 마지막 주문 이후 경과일. 재구매 가능성 예측에 활용.                  |
| `seller_lead_time_stability`   | `orders`, `order_items` (`order_delivered_customer_date`, `order_purchase_timestamp`) | 리드타임 계산 → 표준편차 산출                                  | 셀러 배송 안정성 측정. 표준편차 또는 변동계수 활용.                 |
| `customer_cluster_id`          | 고객 관련 집계 피처 (예: 구매 빈도, 총 주문 수 등)               | 피처 생성 → 정규화 → 클러스터링 알고리즘 적용                | 고객 세분화를 위한 클러스터 ID. 마케팅 및 행동 분석에 활용.         |
| `seller_behavior_embedding`    | 셀러 피처 (예: 리드타임, 평점, 취소율 등)                         | 벡터화 → 임베딩 모델 학습 (`PCA`, `Node2Vec`, `AutoEncoder` 등) | 셀러 행동을 벡터로 표현. 추천 및 유사 셀러 탐색에 활용.              |

## 외부 데이터 필요 피처 요약

| Feature Name               | 구현 방식 요약                                                               |
|----------------------------|------------------------------------------------------------------------------|
| `weather_on_shipping_day` | 계절 기반 하드코딩 / `OpenWeatherMap API` / `INMET` 기상청 크롤링           |
| `is_order_on_holiday`     | `holidays` 라이브러리 / 수동 매핑 / 정부 API                                 |
| `road_strike_indicator`   | 알려진 파업일 하드코딩 / `NewsAPI` / 정부 공지사항 크롤링                    |
| `federal_holiday_flag`    | `is_order_on_holiday`와 통합 / 영업일 기준 판별                              |
| `is_remote_area`          | 주요 도시 기반 분류 / 인구밀도 기준 / GPS 클러스터링 / 경제지표 활용         |

## 피처별 구현 전략

- `customer_avg_order_interval_days`: `groupby + diff` / `SQL LAG` / `numpy` 벡터화
- `days_since_last_order`: 이전 주문일 계산 / `merge_asof` / 벡터화 (데이터 리키지 주의)
- `seller_lead_time_stability`: 표준편차 / 이동 윈도우 / 이상치 제거 후 변동계수
- `customer_cluster_id`: `RFM` → 행동 분석 → 계층적 클러스터링 (단계별 고도화)
- `seller_behavior_embedding`: `PCA` → `Node2Vec` → `AutoEncoder` (복잡도 순)

## 단계별 우선순위

### Phase 1: 기본 구현 (1~2주)
- **목표**: MVP 구축
- **우선 피처**: 공휴일, 주문 간격, 리드타임 안정성
- **전략**: 하드코딩, 무료 라이브러리 사용

### Phase 2: 품질 향상 (2~4주)
- **목표**: 예측 성능 개선
- **우선 피처**: 날씨 정보, 지역 분류, 고객 클러스터링
- **전략**: 외부 API, 벡터화 최적화

### Phase 3: 고도화 (4~8주)
- **목표**: ML 기반 피처 도입
- **우선 피처**: 임베딩, 파업 탐지
- **전략**: 딥러닝, 실시간 처리

## 비용 대비 효과 분석

| 피처                      | 구현 비용 | 성능 향상 | 개발 시간 | ROI 점수 |
|---------------------------|-----------|------------|------------|----------|
| 공휴일 정보               | 낮음      | 중간       | 1일        | ★★★★★    |
| 고객 주문 간격            | 낮음      | 높음       | 2~3일      | ★★★★★    |
| 셀러 안정성               | 중간      | 중간       | 3~5일      | ★★★★     |
| `RFM` 클러스터링          | 중간      | 높음       | 1주        | ★★★★     |
| 날씨 정보                 | 중간      | 낮음       | 1주        | ★★★      |
| 지역 분류                 | 높음      | 중간       | 2주        | ★★★      |
| 파업 탐지                 | 높음      | 낮음       | 2~3주      | ★★       |
| 딥러닝 임베딩             | 매우 높음 | 중간       | 4~6주      | ★★       |

## 구현 시 유의사항

- **데이터 리키지 방지**: 시점 기준 집계, 미래 정보 사용 금지
- **계산 최적화**: 벡터화, 캐싱, `O(n²)` 연산 지양
- **비즈니스 해석 가능성**: 피처 중요도, 도메인 지식, 스테이크홀더와의 소통 고려

## 결론

- 1단계는 쉽고 효과 큰 피처부터 시작 (예: 공휴일, 주문 간격)
- 점진적으로 품질 향상 → 고급 피처 고도화
- ROI와 리스크를 고려해 단계적 실행을 권장